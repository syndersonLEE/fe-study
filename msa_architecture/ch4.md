# 4장 통합

통합에 대한 올바른 이해

## 4.1 이상적인 통합 기술 모색

### 4.1.1 호환성을 깨뜨리는 변경 피하기

- 기존 소비자 서비스에는 변경을 일으키지 않는 기술 선택 요구


### 4.1.2 기술 중립적인 API 생성

- MSA를 통해서 기술 스택을 좌우하는 통합 기술 회피
- 선택의 여지를 둘 수 있음

### 4.1.3 소비자를 위한 서비스 단순화

- 클라이언트에게 기술 선택의 자유는 좋지만 쉽지 않음
- 라이브러리를 제공하는 것이 UX를 고려한 손쉬운 대안

### 4.1.4 내부 구현 상세 감추기

- 내부의 종속 된 코드는 결합도가 높아짐
     - 내부 변경 -> 소비자 변경 -> 호환성 깨짐 -> 변경 비용 증가 -> 변경에 대한 두려움 -> 기술 부채

## 4.2 고객과의 인터페이싱

서비스 통합에 필요한 좋은 기술을 선택하는 데에 좋은 지침

## 4.3 공유 데이터베이스

- 일반적인 형태는 DB 통합
    - 단순하고 가장 짧음

- 단점도 있음
    1. 외부에서 내부의 구현을 조회하고 결합 하는 것을 허용
        - 공격받기 쉬운 대상
        - 변경시 타 서비스에 영향을 주어 중단 가능
        - 사실상 공유 API

    2. 소비자가 기술을 선택하는 데에 큰 제약 사항
        - 하나의 DB이기 때문에 프로그램 특성 상 결정을 바꾸기 어려움
    
    3. 한 곳에서 코어 로직을 변경할 경우 여러 곳에서 행동양식을 변경하고 배포 필요

- 강한 응집력 & 느슨한 결합력하고는 먼 이야기

## 4.4 동기와 비동기

- 동기에서는 서버의 호출이 완료되기 전까지 연산 작업 중지
- 비동기에서는 기다리지 않고 관심없는 겨우도 많음
    - 비동기 기술은 복잡

- res/req모델
    - 동기 통신 방식과 일치
    - 비동기 통신에도 작동
    - 콜백을 등록 가능

- 이벤트 기반 모델
    - 클라이언트에서는 event를 통지한다.
    - 비동기적이고 결합도가 매우 낮은 방식

## 4.5 오케스트레이션과 코레오그래피

- 오케스트레이션 방식
    - 프로세스를 안내하고 하나의 구동하는 중앙 두뇌에 의존
    - 동기 방식 req/res를 사용하면서 수행 단계에 대해 알수 있음
    - 지나친 중앙 집중
    - 높은 변경 비용

- 코레오그래피
    - 각 시스템 별 작업 내용을 통지하고 세부 사항 수행
    - 시스템이 비동기 방식으로 이벤트를 발산
    - 느슨한 결합을 이끌어 낸다
    - 모든 일에 대한 감시 모니터링 시스템 필요
    
## 4.6 원격 프로시저 호출

- 원격 프로시저 호출(RPC)는 local call을 통한 원격 서비스 실행 방법
- SOAP, 쓰리프트, 프로토콜 버퍼 같은 시스템에 의존
- 새로운 공유 인터페이스가 필요 없기 때문에 지역 호출을 원격 호출 처럼 보이게 함
- 추가적인 기능을 제공하는 네트워크 프로토콜 선택 가능 -> 적절하게 선택 가능
- 가장 큰 장점 -> 쉬운 사용성

### 4.6.1 기술 결합

- 특정 기술과 얽혀 있음
- RPC기술은 상호 호환성에 제약

### 4.6.2 지역 호출 != 원격 호출

- RPC는 원격 호출의 복잡함을 은폐하는 것 -> 지나친 은폐
- 서비스 인터페이스 경계를 모르고 막무가내 호출의 가능성

### 4.6.3 취성

- 형편없이 깨질 가능성이 있음
    1. 사용자에게 새로운 객체를 제공할 때 모델을 새로이 생성 해야함
    2. 기존 모델을 수정 할 경우 칼럼이 불필요하건 필요하건 모든 프로젝트에 신규 배포가 필요
         - 네트워크가 모든 정보가 떠돌아 다닐 가능서

### 4.6.4 RPC는 형편 없는가?

- 많은 연산 작업에는 적합
- 현대적 매커니즘은 과거의 단점들을 보완하여 사용
- 사용한다면 주의점 
    1. 원격 호출을 추상화하지 않기
    2. 서버 인터페이스를 발전 시킬 수 있는 지 확인

## 4.7 REST

- REST는 웹에서 영감을 얻은 아키텍쳐
- resource에 대한 개념이 가장 중요
    - HTTP를 통해 가장 많이 사용

### 4.7.1 REST와 HTTP

- GET은 멱등 방식 자원 추출
- POST는 자원 생성
- HTTP 자체로 지원 도구와 거대한 생태계 지원
    - 캐시 프록시, mod_proxy, 많은 모니터링 도구

### 4.7.2 하이퍼미디어

- 어플리케이션 상태 엔진으로서의 하이퍼미디어
    - 서버와 클라가 결합하지 않도록 도와줌
    - 서버 내 고객의 정확한 위치가 필요 없다
    - 클라이언트가 위치만 안다면 내부 구조가 바뀐 다 하더라도 큰 문제 없음
    - 단점 : 컨트롤 탐색에서 많은 호출이 발생 가능

### 4.7.3 JSON, XML and the other

- JSON은 단순한 포맷이고 소비하기 더 쉬움
- 형식이 없기에 콘셉을 자체적으로 정의

### 4.7.4 지나친 편의를 주의

- 마이크로서비스의 영속성을 미루기 위해 -> DB에 저장X, 파일에 저장
- 네트워크 통신 방식이 DB 저장 방법에 영향을 받음

### 4.7.5 HTTP REST의 단점

- 클라이언트의 하이퍼미디어 컨트롤이 좋아졌지만, 서버 - 클라 간 공유 코드는 위험함
- 모든 웹 서비스가 HTTP의 모든 메서드를 제대로 지원하지 않음

- HTTP는 대규모 트래픽에는 좋지만, 네트워킹 기술 기반으로 대체 프로토콜 보다는 별로임
- 지연 시간이 중요하고 작은 메시지에는 어울리지 않음
- 관대한 패턴의 구현 및 동작의 관점에서는 최고

## 4.8 비동기 이벤트 기반의 협업 구현

### 4.8.1 기술 선택

- 두 가지 문제
    - MSA가 이벤트를 발산하는 법
    - 소비자가 이벤트를 찾는 법
- RabbitMQ는 두 가지 문제를 동시에 처리
    - 큐 자체를 소프트웨어에 패키징 -> 많은 지능을 미들웨어에 추가함
    - 엔드포인트를 지능화하고 미들웨어를 멍청하게 만들기

- HTTP를 사용 하는 것
    - 클라에서 피드를 생성하고 소비 가능
    - 피드의 변경을 폴링 필요
    - 기존 라이브러리를 유용하게 재사용 가능
    - 적은 지연 시간에는 안어울린다.

- ATOM
    - 경쟁 소비 패턴 - 메시지를 위해 경쟁하는 다수의 작업 인스턴스를 다루는 방법
    - 모든 작업자간 별도 공유 상태 관리가 필요

### 4.8.2 비동기 아키텍쳐의 복잡성

- 노드의 다운 및 수명이 짧은 비동기 호출에 대해서 저장 여부
- 우선 순위로 인한 큐 처리 문제등 문제가 다수 발생

## 4.9 상태 기계로서의 서비스

- 도메인에 대한 정보는 해당 도메인에서 처리하는 것이 제일 중요

## 4.10 반응형 확장

- Rx로 알려진 반응형 확장
    - 다수의 호출 결과를 조합하고 연산을 실행
    - 그 자체로 블로킹, 논 블로킹 호출
    - RxJava에서는 관찰 대상의 함수를 수행

- 분산 시스템은 호출 방법에 대한 세부사항을 쉽게 추상하고 쉽게 추론
    - 하위 서비스를 쉽게 호출하면서 다수의 호출을 조합 가능

## 4.11 MSA 세계의 코드 재사용의 위험성과 DRY

- Don't Repeat Yourself의 약자
- 중복된 코드를 회피하라
- 변경하기 어렵고 추적하기 어렵다
- 재사용할수 있고 공유 라이브러리를 만들 수도 있음
- 소비자와 MSA간 지나친 결합을 추구 -> 작은 변경 사항이 불필요한 변경 초래

### 4.11.1 클라이언트 라이브러리

- 클라와 서버가 동일한 사람이 만들면 한 쪽의 위험이 다른 쪽에 전파 가능성
- AWS - 하부 API를 추상화 한 SDK를 개발자 직접 만들게 하여 위험을 회피 
- 넷플릭스 - 클라이언트 라이브러리 강조하여 시스템의 신뢰성과 확장성 초래

## 4.12 참조에 의한 접근

- 도메인 개체의 정보를 전달하는 방법
- 참조 - 이벤트 기반 협업을 통해서 상태와 이벤트 발생 자체을 획득 가능
- 해당 서비스를 그대로 참조 -> 서비스 부하 가능성
- 쓸데없는 호출로 결합 위험성


## 4.13 버전 관리

### 4.13.1 가능하면 지연하기

- 애초부터 결함을 안 만들기 위해서 회피 하는 법
- 관심 없는 데이터는 무시할 수 있도록 설계

### 4.13.2 호환성을 깨는 변경 일찍 찾아내기

- CDC, 테스트 수행을 통한 발견

### 4.13.3 유의적 버전 관리

- MAJOR, MINOR, PATCH
    - MAJOR 하위 버전과 호환 X
    - MINOR 호환 유지하며 업데이트
    - PATCH 버그 수정

### 4.13.4 다른 엔드포인트와의 공존

- 엔드 포인트를 여러 버전을 배포
- 확장-수출 패턴의 한 예 -> 이전 기능을 제거하고 API가 축소
- RPC는 상당히 힘듬

### 4.13.5 다수의 병행서비스 버전

- 구 소비자를 구 트래픽, 신규 소비자를 신버전에 라우팅
    1. 수정 할 때, 두곳을 통시에 수정 배포 필요
    2. 소비자가 찾는 서비스를 위한 부가적인 로직 필요
    3. 영속 컨텍스트 고려

## 4.14 사용자 인터페이스

- 사용자에게 보여주기 위한 IF로 가벼운 UI를 고려
- 대표적으로 JS

### 4.14.1 디지털의 향해

- 웹 - 모바일을 묶는 서비스를 생각
- 오프라인 - 온라인 또한 엮음

### 4.14.2 제약

- 각 국가나 시스템의 인터페이스 제약을 고려하여 적절히 활용할 필요가 있음

### 4.14.3 API 구성

- XML, JSON 등을 통한 HTTP 구성
- 단점
     - 다양한 디바이스의 맞춤형 응답이 거의 없음
     - 사용자 인터페이스 생성 주체
     - 통신에 많은 부하를 통해 소비자 요금에도 부담

### 4.14.4 UI 부분 구성

- UI 일부를 직접 제공
- 조립 계층에서 여러 UI 부분을 한곳에 조립하기 위해 URI의 정교한 구성 필요
- 당면한 문제
    1. UX의 일관성 유지
    2. 스스로 UI를 처리하도록 하이브리드 방식 제공 여부
    3. 기능 - 위젯과의 100% 만족 X

### 4.14.5 프론트엔드를 위한 백엔드

- 일반적인 해결책은 엔드포인트 제공
    - 서버 엔드포인트가 너무 많은 역할을 한다

- 프론트를 위한 백엔드 -> 특정 UI를 담당하는 팀이 일부 서버도 담당

### 4.14.6 하이브리드 방식

- 만능일 필요 없음
- 지나치게 많은 행위를 중간 계층에 넣는 방식

## 4.15 외부 소프트웨어와의 통합

1. 소프트웨어 수요량이 내부 공급을 초과
2. 비용면에서 효과적이지 않아서 직접 개발 어려움

- 특별하지 않은 제품으로 구매 하자!

### 4.15.1 통제 부족

- 도구 통합 등에 대한 통제 부족

### 4.15.2 맞춤화

- 내가 원하는 기능으로 맞추기 어려움

### 4.15.3 스파게티 통합

- 통합 유형으로 표준화가 어려움

### 4.15.4 여러분의 방식대로

1. 자체 서비스를 앞에 감추고 내부에 상용소프트웨어 배치
2. 서비스를 하부 서비스화 하여 사용

### 4.15.5 교살자 패턴

- 많은 부분의 코드 교체 없이 기능 교체 가능

### 4.16 마치며

- DB 통합을 최대한 피하라

- REST와 RPC의 장단점을 이해하고 req/res를 통합하는 출발점으로 REST를 고려

- 오케스트레이션 보다는 코레오 그래피

- 포스텔의 법칙을 이해하고 관대한 독자 패턴을 사용하여 호환성을 깨뜨리는 변경과 불핊요한 변경 회피

- 구성 계층으로서 사용자 IF를 생각
`   # 4장 커넥션 관리

### 4.1 TCP 커넥션

- HTTP 통신은 TCP/IP를 이용하여 통신
- 메시지의 손실, 손상 방지, 순서 유지

##### 브라우저 동작 순서

1) URL에서 호스트를 추출
2) 호스트에서 IP주소를 얻는다
3) 포트 번호를 얻음
4) TCP 커넥션 생성
5) HTTP 요청 메시지를 보냄
6) HTTP 응답 메시지를 받음
7) 커넥션을 끊음

##### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

- TCP는 HTTP에게 신뢰할 만한 통신 방식을 제공

##### 4.1.2 TCP 스트림은 세그멘트로 나뉜다

- TCP는 세그멘트 단위로 나눔
- TCP 세그멘트는 IP주소에서 다른 주소로 IP 패킷에 담겨 전달
- IP 패킷의 구성
     - IP 패킷 헤더
     - TCP 세그멘트 헤더
     - TCP 데이터 조각

##### 4.1.3 TCP 커넥션 유지하기

커넥션의 구성 <발신지 IP, 발신지 포트, 수신지 IP, 수신지 포트>

##### 4.1.4 TCP 소켓 프로그래밍

TCP 종단에서 데이터 구조를 연결 -> 데이터 스트림을 읽고 쓰기 가능

- 소켓을 이용한 흐름도 알아보기
    1. 서)소켓생성(socket)
    2. 서)포트로 소켓을 묶음
    3. 서)소켓 커넥션을 허가(listen)
    4. 서)커넥션을 기다린다(accept)
    5. 클)IP주소와 포트를 얻음
    6. 클)소켓 생성(socket)
    7. 클)서버의 IP:PORT를 연결(connect)
    8. 서)application 커넥션 통지
    9. 서)요청을 읽기 시작
    10. 클)연결 성공
    11. 클)HTTP 요청을 보냄(write)
    12. 클)HTTP 요청을 기다림(read)
    13. 서)HTTP 요청 메시지를 처리
    14. HTTP 응답을 주고 받음
    15. 커넥션을 닫음

### 4.2 TCP 성능에 대한 고려

HTTP 성능은 TCP 성능에 영향을 받음

##### 4.2.1 HTTP 트랜잭션 지연

- 지연 원인
    1. IP 주소와 포트 번호 조회 - DNS Resolution 인프라에서 변환(없을 경우)
    2. 새로운 커넥션 설정 과정
    3. HTTP 요청 과정
    4. HTTP 응답 과정

##### 4.2.2 성능 관련 중요 요소

1. TCP 커넥션 핸드셰이크 설정
2. 느린시작
3. 네이글 알고리즘
4. 확인응답 지연 알고리즘
5. TIME_WAIT 지연 포트 고갈

##### 4.2.3 TCP 커넥션 핸드 셰이크 지연

- 작은 크기의 데이터 전송에 커넥션이 사용된다면 잦은 핸드 셰이킹으로 성능을 크게 저하
- 아래는 핸드 셰이크 순서
    1. TCP 커넥션 생성을 위해 'SYN' 플래그를 가진 패킷을 클라 -> 서버로 전송
    2. 서버는 응답으로 'SYN' + 'ACK' 플래그를 포함한 패킷을 서버 -> 클라로 전송
    3. 마지막으로 클라 -> 서버로 커넥션 생성을 보냄

- 패킷 크기가 작다면 TCP 핸드셰이크 1,2번 과정에서 50%를 소모하기 때문에 비효율적

##### 4.2.4. 확인응답 지연

- 인터넷 라우터는 과부하 시 패킷을 파기 -> TCP는 데이터 전송 무결성을 위해 확인 체계 필요
- <b>무결성 체크섬</b>을 이용해서 확인응답 패킷을 송신자 -> 수신자 -> 송신자로 보냄
- 데이터 패킷 전송 효율화를 위해 <b>편승(piggyback)</b>을 위해 버퍼에 저장 후 송출 데이터 패킷에 같이 얹어서 보냄 (히치하이킹)
- 이 때 같이 보낼 패킷이 없을 때에 지연이 발생 (없으면 자체 발송)

##### 4.2.5 TCP 느린 시작

- 최초에 TCP가 한 번에 전송할 수 있는 패킷을 제약 (2개) - 급작스러운 부하와 혼잡을 막기 위해
- 패킷 전달이 성공적 -> 2개 더 드립니다
- 그래서 사용하고 있는 TCP 커넥션을 사용하려고 함

##### 4.2.6 네이글 알고리즘

- 네트워크 효율을 위해 세그멘트가 최대 크기가 될때까지 전송을 대기
- 모든 패킷에서 확인응답을 수신할 경우에는 작은 패킷도 전송을 허락
- HTTP 성능에 문제를 발생시키는 요소
    1. 크기가 작은 패킷
    2. 확인응답 지연 알고리즘의 지연으로 네이글 알고리즘도 느려짐
- TCP_NODELAY 파라미터로 비활성화 가능

##### 4.2.7 TIME_WAIT 누적과 포트 고갈

- 성능 측정시 발생하는 문제
- TCP 커넥션 종료시 control block에 기록하여 같은 주소와 포트 번호로 약 2분간 재생성을 막는다 - 2MSL
- 성능 시험을 할때 포트가 제한되어 있어 TIME_WAIT 포트 고갈이 일어날 수 있음

### 4.3 커넥션 관리

##### 4.3.1 Connection 헤더

- HTTP는 클라 - (프락시 서버 - 캐시 서버 - 리버스 서버) - 서버의 중개를 인정
- HTTP Connection 필드는 가장 인접한 두 서버에만 전달되는 값이고 다음에 끊어져야 할 경우 Connection : close라고 명시
- HTTP 커넥션 헤더의 3가지 토큰 종류
 1. HTTP 헤더 필드 - 이 커넥션에만 해당되는 종류
 2. 임시적인 토큰 - 비표준 옵션
 3. close 값 - 종료 확인

- 홉별 헤더 (다음 서버에만 전달하는 헤더값 - 다음 헤더에서는 삭제)
    1. Proxy-Authenticate
    2. Proxy-Connection
    3. Transfer-Encoding
    4. Upgrade

##### 4.3.2 순차적인 커넥션 처리에 대한 지연

- 순차적 커넥션의 단점
    1. 물리적 지연
    2. 하나의 작업 중 다른 작업이 변화가 없기 때문에 심리적인 문제
    3. 객체의 크기를 모르기 때문에 모든 객체의 완료 이전까지 흰색 화면

- 개선 방안
    1. 병렬 커넥션 - 여러개의 TCP 통신을 동시에
    2. 지속 커넥션 - TCP 커넥션의 재활용
    3. 파이프라인 커넥션 - 공유 TCP 커녁션
    4. 다중 커넥션 - Req & Res간의 중재 (시험 버전)

### 4.4 병렬 커넥션

- 여러 개의 커넥션을 통해 병렬로 처리

##### 4.4.1 병렬 커넥션은 페이지를 빨리 받는다

- 대기 시간을 줄일 수 있다면 더 빠르게 로드 가능
- 커넥션 지연 시간이 겹쳐서 총 지연시간이 감소

##### 4.4.2 병렬 커넥션이 반드시 빠르지는 않음

- 네트워크 대역폭이 좁은 경우
- 과도한 커넥션으로 서버에 과부하(그래서 보통 4개만 허용)

##### 4.4.3 심리적으로 빨리 받는 느낌

- 여러 개의 객체가 한 번에 다운로드하고 있어 빨라져 보임

### 4.5 지속 커넥션

- 기존 커넥션 이후의 커넥션을 재사용하여 느린 시작으로 인한 지연을 피할수 있음
- HTTP 1.1 / HTTP 1.0의 개선 버전

##### 4.5.1 지속 커넥션 vs 병렬 커넥션

- 병렬 커넥션의 단점
    1. 각 트랜잭션 마다 시간과 대역폭이 소요
    2. TCP의 느린 시작
    3. 병렬 커넥션의 수의 제한

- 지속 커넥션의 장점
    1. 작업과 지연을 줄임
    2. 튜닝된 커넥션을 유지
    3. 커넥션을 줄여줌

- 따라서 같이 쓰면 가장 효과적

##### 4.5.2 HTTP/1.0+ Keep-Alive 커넥션

- 설계에 문제가 있어 HTTP 1.1 버전으로 넘어감 - 그러나 아직까지 keep-alive를 사용하는 곳도 있음

##### 4.5.4 Keep-Alive 옵션

- Connection : Keep-alive 헤더가 요청과 응답에 모두 포함되어야 지원 가능
- 옵션
    - timeout 파라미터 - 얼마나 커넥션이 유지될 것인지
    - max 파라미터 - 몇개의 트랜잭션을 처리할 것인가
    - Keep-alive 헤더 - 임의의 속성을 지원

##### 4.5.5 Keep-alive 커넥션 제한 & 규칙

- keep-alive는 1.0에서 사용하려면 Connection : Keep-Alive 헤더를 포함해서 요청해야함
- 모든 메시지에 Connection : Keep-Alive을 포함해야하고 응답에도 포함해야 한다
- Content-Length 값과 정확한 본문 값을 가져야 메시지의 끝을 알 수 있다
- Connection 헤더를 인식 못하는 서버와 맺어지면 안된다 
- HTTP/1.0을 지원하는 기기로 부터 오는 모든 요청 Connection 헤더 필드는 모두 무시해야한다 -> 오래된 프락시 서버가 실수로 전달 할 수 있기 때문이다
- 클라이언트이 응답을 받기 전에 커넥션이 끊어질 경우에는 다시 요청을 보낼 수 있어야한다 - 반복 요청 금지!

##### 4.5.6 Keep-alive와 멍청한 프락시

- 멍청한 Proxy 서버는 Connection에 대한 처리를 하지 않고 요청을 다음 프락시에 전달
- 문제 상황1 - 멍청한 Proxy 서버가 있을 경우
    1. 클라이언트가 Header에 Connection : Keep-Alive을 담아 전송
    2. Proxy 서버가 서버로 Connection : Keep-Alive을 그대로 전달
    3. 서버는 Connection : Keep-Alive을 수신하여 Keep-Alive 통신으로 이해하고 응답
    4. 클라 - 프락시 - 서버 3자간 Keep-Alive 하고 있다고 이해하지만 프록시에서는 지원하지 않음
    5. 해당 커넥션에 추가 요청을 보내지만 프록시 서버는 같은 커넥션을 쓴다고 생각못하여 무시가 되고 무한 로딩
    6. 서버가 타임아웃이 나와 커넥션이 끊길 때 까지 대기

##### 4.5.7 Proxy-Connection

- Proxy-Connection : Keep-Alive 옵션을 사용하여 해결
- 멍청한 Proxy와 영리한 Proxy 서버가 섞여 있으면 똑같은 문제

##### 4.5.8 HTTP/1.1 지속 커넥션

- 1.1에서는 지속 커넥션이 기본 옵션

##### 4.5.9 지속 커넥션의 제한과 규칙

- Connection : close 헤더가 포함되어 있으면 해당 커넥션으로 추가 요청 불가
- Content-Length가 정확한 값을 가지고, 청크 전송 인코딩으로 인코딩 되어 있어야 함
- HTTP/1.1 프락시 서버는 클라이언트의 지원 범위를 알고 있지 않으면 지속 커넥션을 하면 안되지만 잘 지켜지지 않음
- 중간에 끊어지는 커넥션을 복구 가능해야한다
- 클라이언트는 2개의 지속 커넥션 정도만 유지해야한다

### 4.6 파이프라인 커넥션

- 지속 커넥션의 요청을 큐에 쌓아 성능을 높이는 방법
- 제약 사항
    - 지속 커넥션 여부 확인
    - 응답과 요청 순서가 같아야한다
    - 요청을 언제든지 재전송할 수 있어야한다
    - POST 요청 같이 반복 요청 시 문제가 될 경우는 보내면 안된다 (문제 발생시 큰일 남)

### 4.7 커넥션 끊기의 미스테리

##### 4.7.1 '마음대로' 커넥션 끊기

- 에러가 발생하면 어디서 끊길지 모름

##### 4.7.2 Connection-Length와 Truncation

- 엔티티의 길이와 Content-Length의 값이 일치하지 않거나 헤더를 생략한 경우

##### 4.7.3 커넥션 끊기의 허용, 멱등성

- POST의 경우 반복 전송이 문제 발생 소지가 다분
- 나머지는 결과적으로는 아무런 문제가 없기 떄문에 다시 보내기 가능

##### 4.7.4 우아한 커넥션 끊기

- close()는 입력과 출력을 동시에 끊고, shutdown()은 절반만 끊는다
- 절반 끊기는 파이프라인 지속 커넥션을 이용할 때 쓰기 에러를 발생 예방을 위해 절반 끊기를 사용
- 일반적으로 출력 채널을 끊음 -> 입력 채널을 끊을 경우 서버가 'connection reset by peer' 에러를 반환하여 심각한 오류로 취급함 -> 버퍼 내의 읽히지 않은 데이터를 모두 삭제
- 파이프라인 커넥션이 끊길 경우 이전에 수신하고 발송한 모든 데이터가 삭제될 위험성

- 우아하게 커넥션 끊기 -> 출력 채널만 끊음으로서 더 이상 데이터 전송이 안될 것이라 알려줌 
- 이것만으로는 보장이 안되기 떄문에 입력 채널에 대한 검사를 주기적으로 해야함

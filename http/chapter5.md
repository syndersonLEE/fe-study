# 5장 웹 서버

##### 5.1.1 웹 서버의 구현

- HTTP 및 TCP 처리를 구현
- 운영체제와 TCP 커넥션의 관리를 나눠 가짐

##### 5.1.2 다목적 소프트웨어 웹 서버

- 점유율
    1. 아파치 웹서버
    2. 마이크로소프트 웹서버
    3. nginx 웹서버
    4. 기타 등등

##### 5.1.3 임베디드 웹 서버

- 소비자용 제품에 내장될 목적

### 5.2 펄 웹서버

- HTTP/1.1의 기능은 1.풍부한 리소스 지원 2.가상 호스팅 3.접근 제어 4.로깅 5.설정 6.모니터링 등의 기능이 필요
- 코드 내의 특징 요약
    1. 포트 설정(기본 8080포트)
    2. TCP 소켓을 생성하고 커넥션을 기다림(listen)
    3. 시작 메시지 출력
    4. 커넥션을 기다림(while문을 통해)
    5. 커넥션 출처을 출력
    6. 요청 메시지를 끝까지 읽음
    7. 응답을 위한 프롬프트 생성하여 응답

### 5.3 진짜 웹서버

1. 커넥션 맺기
2. 요청 받기
3. 요청 처리
4. 리소스 접근
5. 응답 생성
6. 응답 보내기
7. 트랜잭션을 로그로 남김

### 5.4 클라이언트 커넥션 수락

- 서버 입장에서 서술

##### 5.4.1 새 커넥션 다루기

- TCP 커넥션에서 IP 주소를 추출
- 새 커넥션을 목록에 추가하고 데이터를 지켜봄

##### 5.4.2 클라이언트 호스트 명 식별

- 서버는 reverse DNS를 활용하여 IP를 호스트로 변환 가능 (또한 접근 제어와 로깅에 사용)
- 그러나 웹 트랜잭션을 느려지게 할 수 있음

##### 5.4.3 ident를 통해 클라이언트 사용자를 알아냄

- IETF ident 프로토콜은 HTTP 커넥션을 초기화 한 사용자를 알려줌
- TCP 113포트를 통해 ident 프로토콜을 확인하는 과정
    1. HTTP 커넥션을 연다
    2. identd 서버 포트를 연다
    3. 이름을 물어봄

- ident는 공공 인터넷에서 사용이 어려움
    - 많은 PC에서 identd 프로토콜 소프트웨어를 실행 X
    - HTTP 트랜잭션을 지연
    - 방화벽에 막힘
    - 안전하지 않고 조작이 쉬움
    - 가상 IP를 잘 지원하지 않음
    - 프라이버시 침해의 우려
- 따라서 - 로 채움

### 5.5 요청 메시지 수신

- 메서드, URI, 버전 번호를 파싱하고 CRLF 문자열로 끝냄
- 본문이 있으면 본문을 읽음

##### 5.5.1 메시지의 내부 표현

- 헤더에 저장하여 신속하게 접근 가능

##### 5.5.2 커넥션 입출력 아키텍쳐

- 웹 서버 아키텍처는 새 요청을 항시 대기

- 단일 스레드 웹 서버
    - 한 번에 하나씩 요청을 처리하고 다른 커넥션은 무시
    - 성능 문제가 발생

- 멀티 프로세스와 멀티 스레드 서버
    - 매 커넥션마다 스레드나 프로세스를 할당하기 떄문에 최대 개수에 제약을 건다

- 다중 I/O서버
    - 대부분의 웹 서버의 구동 방식
    - 커넥션에 대해 작은 양의 처리 후 완료가 되면 열린 커넥션 목록으로 돌아가면서 리소스 낭비를 줄임

- 다중 멀티스레드 웹 서버
 - 멀티스레딩과 다중 I/O를 결합하여 여러 개의 레드와 열려있는 스레드를 감시하고 조금씩 수행

- 아파치 
    - 멀티 프로세스 & 멀티 스레드
        - Prefork 
            - 상위 프로세스가 하위 프로세스에 할당하여 하나의 프로세스(Thread)가 하나의 작업을 담당함
            - 미리 프로세스를 만들어두고 요청이 들어올때마다 할당

        - Worker
            - 상위 프로세스가 하위 쓰레드에 할당하여 하나의 프로세스가 여러 개의 Thread를 가지며, 하나의 Thread에서 하나의 작업을 담당
            - 자원을 상대적으로 적게 사용

        - 자원이 한정적이라 많은 요청 처리가 힘들다

- Ngnix
    - Event Driven & 비동기 처리
        - 요청이 오면 Request Queue에 저장하여 Event Loop를 돌면서 Thread Pool에 작업을 할당하는 구조(싱글스레드 But 내부적으로는 멀티 스레드)


 ### 5.6 요청 처리

 뒷 장에서 대대적으로 다룰 예정

 ### 5.7 리소스 매핑과 접근
 
- baseroot를 docroot로 지적하여 뒤에 /usr/local 같은 방식으로 파일 명을 명시하고 반환
- 이 때 파일 명을 제외하고 상위 root에 대한 접근을 허용하지 않음

##### 가상 호스팅된 docroot

- 클라이언트가 요청하면 가상 호스팅 웹 서버는 URI을 분리된 콘텐츠로 리다이렉팅하여 해당 요청으로 전달


##### 5.7.2 디렉터리 목록

- 기본적으로 디렉터리의 index.html, index.htm을 디폴트로 반환
- 디폴트 파일이 없다면 파일들을 나열 (옵션으로 제거 가능)

##### 5.7.3 동적 리소스 매핑

- 스크립트를 통해서 특정 확장자나 접두어로 시작하는 파일을 로딩 가능

##### 5.7.4 서버사이드 인클루드

- 클라이언트에 보내기 전에 검사를 받고 출력값으로 치환 가능

##### 5.7.5 접근 제어

IP 주소에 근거하여 접근을 제어하거나 비밀번호를 통해 확인 가능

### 5.8 응답 만들기

- 응답 상태 코드, 헤더, 본문을 포함하여 응답

##### 5.8.1 응답 엔터티

- 본문의 타입을 서술하는 Content-Type 헤더
- 길이 Content-Length
- 본문

##### 5.8.2 MIME 타입을 결정

- mime-types 확장자
- 매직 타입 - 확장자가 없을 경우 패턴 테이블을 탐색
- 유형 명시 - 서버가 명시
- 유형 협상 - 사용자와 협상하여 명시

### 5.8.3 리다이렉션

- 요청을 수행하기 위해 다른곳으로 가도록 리다이렉트

- 유용한 케이스
     - 영구히 리소스가 옮겨진 경우
     - 임시로 리소스가 옮겨진 경우
     - URL 증강
     - 부하 균형 
     - 친밀한 다른 서버
     - 디렉터리 이름 정규화

### 5.9 응답 보내기

### 5.10 로깅

- 로그 파일에 기록